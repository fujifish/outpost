#!/usr/bin/env node

var fs = require('fs');
var path = require('path');
var http = require('http');
var Outpost = require('../lib/outpost');

// load and parse the outpost configuration
function _outpostConfig(config) {
  config = config || 'config.json';
  var conf = {};
  try {
    // either given a config as string or file name
    if (config.trim().charAt(0) !== '{') {
      config = fs.readFileSync(path.resolve(__dirname, '../' + config));
    }
    conf = JSON.parse(config);
  } catch (err) {
    console.error('failed to load outpost config: ' + err.message);
    process.exit(1);
  }
  return conf;
}

// process command line options to get the command to execute
var command = require('../lib/cli').process();

function _handleCommand(command, cb) {

  // special handling of starting outpost in daemon mode
  if (command.type === 'daemon') {
    process.title = 'outpost-agent';
    var config = _outpostConfig(command.config);
    var outpost = new Outpost(config);
    outpost.start(function(err) {
      // notify the spawner that we're ready
      if (process.send) {
        process.send(err || 'agent started');
      } else {
        console.log(err || 'agent started');
      }
      if (err) {
        process.nextTick(function() {
          process.exit(1);
        });
      }
    });

    outpost.on('close', function() {
      setImmediate(function() {
        process.exit(0);
      });
    });

    return;
  }

  // special handling of agent commands
  if (command.type === 'agent') {
    switch (command.action) {

      case 'restart':
        _handleCommand({type: 'agent', action: 'stop', silent: true}, function(err, message) {
          if (message) {
            console.log(message);
          }
          _handleCommand({type: 'agent', action: 'start'}, function(err, message) {
            cb && cb(err, message);
          });
        });

        return;

      case 'start':
        var child = require('child_process').spawn(process.execPath, [__filename, '--daemon', '--opconfig', command.opConfig || 'config.json'], {
          cwd: path.resolve(__dirname, '..'),
          env: process.env,
          stdio:  ['ignore', 'ignore', 'ignore', 'ipc'],
          detached: true
        });

        child.on('message', function(message) {
          child.disconnect();
          child.unref();
          if (message === 'agent started' || message === 'agent is already running') {
            cb && cb(null, message);
          } else {
            cb && cb(message);
          }
        });
        return;

      case 'stop':
        command.silent = true;
        break;
    }
  }

  // all other commands are sent to the agent
  config = _outpostConfig(command.opConfig);
  delete command.opConfig;
  var postData = JSON.stringify(command);

  var requestOptions = {
    hostname: '127.0.0.1',
    port: (config && config.cliport) || Outpost.prototype.CLIPORT,
    path: '/',
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Content-Length': postData.length
    }
  };

  var req = http.request(requestOptions, function(res) {
    res.on('data', function(data) {
      process.stdout.write(data);
    });
    res.on('end', function() {
      cb && cb();
    });
  });

  req.on('error', function(e) {
    var message;
    var error = 'error';
    if (e.code === 'ECONNREFUSED') {
      error = null;
      message = 'agent not running';
    } else {
      message = 'error communicating with the outpost agent: ' + e.message;
    }
    cb && cb(error, message);
  });

  // write data to request body
  req.write(postData);
  req.end();

}

_handleCommand(command, function(err, message) {
  if (message) {
    console.log((err ? (err + ': ') : '') + message);
  }

  if (err) {
    process.exit(1);
  }
  process.exit(0);
});

